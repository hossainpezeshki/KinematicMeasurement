---
title: "Kinematic measurement data"
author: "Hossain Pezeshki"
date: '2015-05-05'
output: html_document
---

# Prompt #
I was asked by a firm (as a test) to characterize and describe a given data set `data.csv`.
I will be using the following libraries:

```r
library (pracma)  # Matlab like commands for R
library (signal)  # A signal processing toolbox for pracma
```

```
## 
## Attaching package: 'signal'
## 
## The following objects are masked from 'package:pracma':
## 
##     conv, ifft, interp1, pchip, polyval, roots
## 
## The following objects are masked from 'package:stats':
## 
##     filter, poly
```

```r
library (scatterplot3d)
```

# Inspecting the data #
The names of the columns in the file suggest that the content consists of periodic measurements
generated by an accelerometer and a gyroscope presumably attached to a rigid body.
I assume that the objective of such measurements is to infer the **position** and
**orientation** of the object.
Accordingly, inferring the change in position and in orientation are my aims in this document.


```r
gdat <- read.csv (file="data.csv")
```

```
## Warning in file(file, "rt"): cannot open file 'data.csv': No such file or
## directory
```

```
## Error in file(file, "rt"): cannot open the connection
```

```r
colnames (gdat)
```

```
## Error in is.data.frame(x): object 'gdat' not found
```

The first column appears to be just the sample number, so I remove it.

```r
gdat <- gdat[,2:8]
```

```
## Error in eval(expr, envir, enclos): object 'gdat' not found
```

# Inferring the position of the centre of mass #
From elementary mechanics we know that acceleration $a(t)\in R^3$, velocity $v(t) \in R^3$ 
and position $x(t) \in R^3$
are related as:

$$ v(t) = v(0) + \int_0^t a(s)\,ds$$
$$ x(t) = x(0) + \int_0^t v(s)\,ds$$

Without loss of generality we assume that the object is at rest $v(0)=0$, and is located at the centre
of the coordinate system $x(0) = 0\in R^3$. The following code fragment estimates the change
in the position and plots it.


```r
acceleration <- as.matrix (gdat[, c(2:4)])
```

```
## Error in as.matrix(gdat[, c(2:4)]): object 'gdat' not found
```

```r
velocity <- cumtrapz (gdat$time, acceleration)  # Trapezoidal rule approximation of the integrals.
```

```
## Error in cumtrapz(gdat$time, acceleration): object 'gdat' not found
```

```r
position <- cumtrapz (gdat$time, velocity)
```

```
## Error in cumtrapz(gdat$time, velocity): object 'gdat' not found
```

```r
scatterplot3d (position[,1], position[,2], position[,3],
				highlight.3d=TRUE, pch=20, cex.symbols=0.15,
				xlab="x axis", ylab="y axis", zlab="z axis")
```

```
## Error in scatterplot3d(position[, 1], position[, 2], position[, 3], highlight.3d = TRUE, : object 'position' not found
```

# Inferring the change in orientation #
In this section I am using the online kinematics tutorial
found at [http://www.euclideanspace.com/physics/kinematics/angularvelocity](http://www.euclideanspace.com/physics/kinematics/angularvelocity).

Estimating the orientation is more involved than estimating the position. 
Let $\omega(t) \in R^3$ be the instantaneous 
rotational velocity as given in the file. Then the change in orientation is given by
an orthogonal **rotation matrix** $D(t) \in R^{3\times3}$ which must be obtained
as the solution of the matrix differential equation

$$ \dfrac{d D(t)}{dt} = W(t)\,D(t)\;\mbox{ subject to } D(0) = 
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix} $$
where $W(t)$ is a three-by-three matrix which is obtained from instantaneous
measured angular velocities $\omega(t)$ as:

$$ W = \begin{bmatrix}
0 & -\omega_3 & \omega_2 \\
\omega_3 & 0 & -\omega_1 \\
-\omega_2 & \omega_1 & 0 
\end{bmatrix} $$

The following code fragment performs the $\omega$ to $W$ transformation.

```r
toW <- function (om) {
  tmp <- matrix (data=rep(0,9), nrow=3, ncol=3)
  tmp[1,2] = -om[3]; tmp[1,3] = om[2];
  tmp[2,1] = om[3]; tmp[2,3] = -om[1];
  tmp[3,1] = -om[2]; tmp[3,2] = om[1];
  tmp
}
```

Thus if $u(0)$ is a unit vector indicating the initial orientation of the object,
then $D(t) u(0)$ is a **unit vector** that gives the orientation of the object
at time $t$.

We now have to solve for $D(t)$.
After considering issues of numeric stability I chose the method of **backward Euler** which
in the present context becomes:

$$ D(n\,\Delta t) \approx D((n-1)\,\Delta t) + \Delta t\, W(n\,\Delta t)\, D(n\,\Delta t)$$
From which one obtains the implicit $n$'th step approximation as:
$$ D(n\,\Delta t) \approx \left(I - \Delta t\, W(n\,\Delta t)\right)^{-1}\, D((n-1)\,\Delta t)$$

In order to further enforce numerical stability, we use the fact that $D$ must be unitary;
that is
for all $t$ it must be true that $\left(D(t)\right)^{-1} = \left(D(t)\right)^{\top}$.

In my initial experiments I took $\Delta t$ to be the sampling period of the original data
, i.e. about $0.047619$ seconds. This, however, proved too coarse (since the $\omega$ measurements
are visibly extremely noisy) and the numerical accuracy of my approximate ODE solution failed quickly.
Therefore I had to reduce $\Delta t$; but since $\omega$ sampling rate is fixed, 
the signal must be interpolated. Interpolating signals is well known to DSP engineers
whose jargon for it is __up-sampling__. The `signal` package in `R` provides such
a function whose mathematical justification can be found
at [this Stanford University link](https://ccrma.stanford.edu/~jos/resample/Theory_Ideal_Bandlimited_Interpolation.html).
The implementation is given below:



```r
omega <- as.matrix (gdat[,5:7])   # Get the rotational velocities
```

```
## Error in as.matrix(gdat[, 5:7]): object 'gdat' not found
```

```r
h <- mean (diff (gdat$time, lag=1)) # The samples are evenly spaced but for tiny variations.
```

```
## Error in diff(gdat$time, lag = 1): object 'gdat' not found
```

```r
Nobs <- dim (omega)[1]			# The original number of observations
```

```
## Error in eval(expr, envir, enclos): object 'omega' not found
```

```r
p = 10; q=1;  	# omega signal will be interpolated at the rate of p/q
upsomega <- sapply (1:3, function (i) {resample (omega[,i], p, q)})  # upsampled omega
```

```
## Error in seq.default(1, length(x) + 1 - 1/r, by = 1/r): object 'omega' not found
```

```r
dt = (h * q) / p;  # Delta t is shrunk by q/p
```

```
## Error in eval(expr, envir, enclos): object 'h' not found
```

```r
Nup = dim (upsomega)[1]			# The new number of samples
```

```
## Error in eval(expr, envir, enclos): object 'upsomega' not found
```

```r
Dt <- list ()
Dt[[1]] <- eye(3)

uptime = vector ("numeric", length = Nup)  # This is the new discrete time axis
```

```
## Error in vector("numeric", length = Nup): object 'Nup' not found
```

```r
uptime[1] = dt;
```

```
## Error in uptime[1] = dt: object 'uptime' not found
```

```r
for (k in 2:Nup) {
  W = toW (upsomega[k,])
  
  tmp = eye(3) - dt * W
  Dt[[k]] = inv (tmp) %*% Dt[[k-1]]			# Note the backward/implicit Euler
  Dt[[k]] = (1/2) * (Dt[[k]] + inv (t (Dt[[k]])));	# This to ensure D(t) remains unitary
  
  uptime[k] = dt + uptime[k-1];
}
```

```
## Error in eval(expr, envir, enclos): object 'Nup' not found
```

We can now inspect the results by following the action of $D(t)$ on $u(0) = [1,0,0]^\top$.

```r
u <- matrix (rep (0.0, 3*Nup), ncol=3)
```

```
## Error in matrix(rep(0, 3 * Nup), ncol = 3): object 'Nup' not found
```

```r
u[1,] <- c(1,0,0)
```

```
## Error in u[1, ] <- c(1, 0, 0): object 'u' not found
```

```r
for (k in 2:Nup) {
  u[k,] <- Dt[[k]] %*% u[1,]
}
```

```
## Error in eval(expr, envir, enclos): object 'Nup' not found
```

```r
lengths <- sapply (1:dim(u)[1], function (i) {sqrt(t(u[i,]) %*% u[i,])})
```

```
## Error in lapply(X = X, FUN = FUN, ...): object 'u' not found
```

```r
u = u / lengths;
```

```
## Error in eval(expr, envir, enclos): object 'u' not found
```

```r
scatterplot3d (u[,1], u[,2], u[,3], highlight.3d=TRUE, pch=20, cex.symbols=0.1)
```

```
## Error in scatterplot3d(u[, 1], u[, 2], u[, 3], highlight.3d = TRUE, pch = 20, : object 'u' not found
```

Apart from the mass of uniformly distributed noise, one can clearly discern the red curve in the plot,
indicating that the above procedure has been able to infer the orientation at least for some of
the time. A systems' level solution to the problem, however, would strive to obtain cleaner less noisy
measurements of instantaneous rotational velocities.
<br><br><br>





















